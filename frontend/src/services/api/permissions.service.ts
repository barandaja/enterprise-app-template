/**
 * @fileoverview Permissions API Service
 * 
 * Enterprise-grade permissions service providing:
 * - RBAC operations with type-safe permission keys
 * - Role management with hierarchical structures
 * - Permission checking with context awareness
 * - Audit logging for permission changes
 * - Policy-based access control (PBAC)
 * - Permission caching and optimization
 * - Real-time permission updates
 * - Bulk operations for enterprise scalability
 */

import { z } from 'zod';
import { apiClient } from './client';
import type {
  ApiResponse,
  ApiRequestConfig,
  PaginatedResponse,
  EnhancedApiRequestConfig,
  Permission,
  Role,
  UserRoleAssignment,
  PermissionCheckRequest,
  PermissionCheckResult,
  PermissionAuditLog,
  PermissionResource,
  PermissionAction,
  PermissionScope,
} from './types';

// =============================================================================\n// Well-Known Permissions System\n// =============================================================================\n\n/**\n * Well-known permission resources\n */\nexport const RESOURCES = {\n  USER: 'user' as const,\n  ROLE: 'role' as const,\n  PERMISSION: 'permission' as const,\n  NOTIFICATION: 'notification' as const,\n  PREFERENCE: 'preference' as const,\n  AUDIT: 'audit' as const,\n  SYSTEM: 'system' as const,\n  ORGANIZATION: 'organization' as const,\n  TEAM: 'team' as const,\n  PROJECT: 'project' as const,\n  DOCUMENT: 'document' as const,\n  REPORT: 'report' as const,\n} as const;\n\n/**\n * Well-known permission actions\n */\nexport const ACTIONS = {\n  CREATE: 'create' as const,\n  READ: 'read' as const,\n  UPDATE: 'update' as const,\n  DELETE: 'delete' as const,\n  LIST: 'list' as const,\n  EXECUTE: 'execute' as const,\n  MANAGE: 'manage' as const,\n  APPROVE: 'approve' as const,\n  PUBLISH: 'publish' as const,\n  EXPORT: 'export' as const,\n  IMPORT: 'import' as const,\n  SHARE: 'share' as const,\n} as const;\n\n/**\n * Common permission combinations\n */\nexport const PERMISSION_SETS = {\n  // Basic CRUD\n  FULL_ACCESS: [ACTIONS.CREATE, ACTIONS.READ, ACTIONS.UPDATE, ACTIONS.DELETE, ACTIONS.LIST] as const,\n  READ_ONLY: [ACTIONS.READ, ACTIONS.LIST] as const,\n  EDITOR: [ACTIONS.READ, ACTIONS.UPDATE, ACTIONS.LIST] as const,\n  CREATOR: [ACTIONS.CREATE, ACTIONS.READ, ACTIONS.LIST] as const,\n  \n  // Administrative\n  ADMIN: [ACTIONS.CREATE, ACTIONS.READ, ACTIONS.UPDATE, ACTIONS.DELETE, ACTIONS.LIST, ACTIONS.MANAGE] as const,\n  MODERATOR: [ACTIONS.READ, ACTIONS.UPDATE, ACTIONS.LIST, ACTIONS.APPROVE] as const,\n  \n  // Content management\n  PUBLISHER: [ACTIONS.CREATE, ACTIONS.READ, ACTIONS.UPDATE, ACTIONS.PUBLISH, ACTIONS.LIST] as const,\n  REVIEWER: [ACTIONS.READ, ACTIONS.APPROVE, ACTIONS.LIST] as const,\n} as const;\n\n/**\n * System roles with predefined permissions\n */\nexport const SYSTEM_ROLES = {\n  SUPER_ADMIN: 'system.super_admin' as const,\n  ADMIN: 'system.admin' as const,\n  MODERATOR: 'system.moderator' as const,\n  USER: 'system.user' as const,\n  GUEST: 'system.guest' as const,\n} as const;\n\n// =============================================================================\n// Validation Schemas\n// =============================================================================\n\n/**\n * Permission scope validation schema\n */\nconst permissionScopeSchema = z.object({\n  type: z.enum(['global', 'organization', 'team', 'user', 'resource']),\n  value: z.string().optional(),\n  conditions: z.record(z.unknown()).optional(),\n});\n\n/**\n * Permission creation schema\n */\nconst createPermissionSchema = z.object({\n  name: z.string().min(1).max(255),\n  description: z.string().max(500).optional(),\n  resource: z.string().min(1).max(100),\n  action: z.string().min(1).max(100),\n  scope: permissionScopeSchema,\n  conditions: z.record(z.unknown()).optional(),\n});\n\n/**\n * Role creation schema\n */\nconst createRoleSchema = z.object({\n  name: z.string().min(1).max(255),\n  description: z.string().max(500).optional(),\n  permissions: z.array(z.string()).default([]), // Permission IDs\n  parentRoleId: z.string().optional(),\n  metadata: z.object({\n    level: z.number().int().min(0).default(0),\n    priority: z.number().int().min(0).default(0),\n    tags: z.array(z.string()).default([]),\n  }).default({}),\n});\n\n/**\n * Role assignment schema\n */\nconst assignRoleSchema = z.object({\n  userId: z.string().min(1),\n  roleId: z.string().min(1),\n  scope: permissionScopeSchema.optional(),\n  expiresAt: z.string().datetime().optional(),\n});\n\n/**\n * Permission check schema\n */\nconst permissionCheckSchema = z.object({\n  userId: z.string().min(1),\n  resource: z.string().min(1),\n  action: z.string().min(1),\n  scope: permissionScopeSchema.optional(),\n  context: z.record(z.unknown()).optional(),\n});\n\n/**\n * Bulk permission check schema\n */\nconst bulkPermissionCheckSchema = z.object({\n  userId: z.string().min(1),\n  checks: z.array(z.object({\n    resource: z.string().min(1),\n    action: z.string().min(1),\n    scope: permissionScopeSchema.optional(),\n    context: z.record(z.unknown()).optional(),\n  })),\n});\n\n// =============================================================================\n// Permission Policy Engine\n// =============================================================================\n\n/**\n * Policy condition evaluator\n */\ninterface PolicyCondition {\n  field: string;\n  operator: 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte' | 'in' | 'not_in' | 'contains' | 'starts_with' | 'ends_with';\n  value: unknown;\n}\n\n/**\n * Policy rule definition\n */\ninterface PolicyRule {\n  id: string;\n  name: string;\n  description?: string;\n  resource: PermissionResource;\n  action: PermissionAction;\n  effect: 'allow' | 'deny';\n  conditions: PolicyCondition[];\n  priority: number;\n}\n\n/**\n * Policy evaluation context\n */\ninterface PolicyContext {\n  user: {\n    id: string;\n    roles: string[];\n    attributes: Record<string, unknown>;\n  };\n  resource: {\n    type: PermissionResource;\n    id?: string;\n    attributes: Record<string, unknown>;\n  };\n  environment: {\n    time: string;\n    ipAddress?: string;\n    userAgent?: string;\n    location?: string;\n  };\n  request: {\n    action: PermissionAction;\n    parameters: Record<string, unknown>;\n  };\n}\n\n/**\n * Policy evaluation result\n */\ninterface PolicyEvaluationResult {\n  decision: 'allow' | 'deny' | 'not_applicable';\n  matchedRules: PolicyRule[];\n  reason: string;\n  metadata: Record<string, unknown>;\n}\n\n/**\n * Client-side policy evaluator (for caching and quick checks)\n */\nclass PolicyEvaluator {\n  private rules: PolicyRule[] = [];\n\n  /**\n   * Load policy rules\n   */\n  loadRules(rules: PolicyRule[]): void {\n    this.rules = rules.sort((a, b) => b.priority - a.priority);\n  }\n\n  /**\n   * Evaluate permission request against policies\n   */\n  evaluate(context: PolicyContext): PolicyEvaluationResult {\n    const matchedRules: PolicyRule[] = [];\n    \n    for (const rule of this.rules) {\n      if (this.matchesRule(rule, context)) {\n        matchedRules.push(rule);\n        \n        // First matching rule determines the decision\n        return {\n          decision: rule.effect,\n          matchedRules: [rule],\n          reason: `Matched rule: ${rule.name}`,\n          metadata: { ruleId: rule.id, priority: rule.priority },\n        };\n      }\n    }\n\n    return {\n      decision: 'not_applicable',\n      matchedRules: [],\n      reason: 'No matching policy rules found',\n      metadata: {},\n    };\n  }\n\n  /**\n   * Check if a rule matches the context\n   */\n  private matchesRule(rule: PolicyRule, context: PolicyContext): boolean {\n    // Check resource and action match\n    if (rule.resource !== context.resource.type || rule.action !== context.request.action) {\n      return false;\n    }\n\n    // Evaluate conditions\n    return rule.conditions.every(condition => this.evaluateCondition(condition, context));\n  }\n\n  /**\n   * Evaluate a single condition\n   */\n  private evaluateCondition(condition: PolicyCondition, context: PolicyContext): boolean {\n    const fieldValue = this.getFieldValue(condition.field, context);\n    \n    switch (condition.operator) {\n      case 'eq':\n        return fieldValue === condition.value;\n      case 'ne':\n        return fieldValue !== condition.value;\n      case 'gt':\n        return typeof fieldValue === 'number' && typeof condition.value === 'number' && fieldValue > condition.value;\n      case 'gte':\n        return typeof fieldValue === 'number' && typeof condition.value === 'number' && fieldValue >= condition.value;\n      case 'lt':\n        return typeof fieldValue === 'number' && typeof condition.value === 'number' && fieldValue < condition.value;\n      case 'lte':\n        return typeof fieldValue === 'number' && typeof condition.value === 'number' && fieldValue <= condition.value;\n      case 'in':\n        return Array.isArray(condition.value) && condition.value.includes(fieldValue);\n      case 'not_in':\n        return Array.isArray(condition.value) && !condition.value.includes(fieldValue);\n      case 'contains':\n        return typeof fieldValue === 'string' && typeof condition.value === 'string' && fieldValue.includes(condition.value);\n      case 'starts_with':\n        return typeof fieldValue === 'string' && typeof condition.value === 'string' && fieldValue.startsWith(condition.value);\n      case 'ends_with':\n        return typeof fieldValue === 'string' && typeof condition.value === 'string' && fieldValue.endsWith(condition.value);\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Get field value from context using dot notation\n   */\n  private getFieldValue(field: string, context: PolicyContext): unknown {\n    const parts = field.split('.');\n    let value: any = context;\n    \n    for (const part of parts) {\n      if (value && typeof value === 'object' && part in value) {\n        value = value[part];\n      } else {\n        return undefined;\n      }\n    }\n    \n    return value;\n  }\n}\n\n// =============================================================================\n// Permission Cache Manager\n// =============================================================================\n\n/**\n * Permission cache entry\n */\ninterface PermissionCacheEntry {\n  result: PermissionCheckResult;\n  timestamp: number;\n  ttl: number;\n}\n\n/**\n * Permission cache manager with intelligent invalidation\n */\nclass PermissionCache {\n  private cache = new Map<string, PermissionCacheEntry>();\n  private userRoleCache = new Map<string, { roles: string[]; timestamp: number }>();\n  private defaultTTL = 300000; // 5 minutes\n  private roleTTL = 600000; // 10 minutes\n\n  /**\n   * Get cached permission result\n   */\n  get(userId: string, resource: string, action: string, scope?: PermissionScope): PermissionCheckResult | null {\n    const key = this.generateKey(userId, resource, action, scope);\n    const entry = this.cache.get(key);\n    \n    if (entry && Date.now() - entry.timestamp < entry.ttl) {\n      return entry.result;\n    }\n    \n    // Remove expired entry\n    if (entry) {\n      this.cache.delete(key);\n    }\n    \n    return null;\n  }\n\n  /**\n   * Set cached permission result\n   */\n  set(\n    userId: string,\n    resource: string,\n    action: string,\n    result: PermissionCheckResult,\n    scope?: PermissionScope,\n    ttl?: number\n  ): void {\n    const key = this.generateKey(userId, resource, action, scope);\n    this.cache.set(key, {\n      result,\n      timestamp: Date.now(),\n      ttl: ttl || this.defaultTTL,\n    });\n  }\n\n  /**\n   * Invalidate cache for specific user\n   */\n  invalidateUser(userId: string): void {\n    const keysToDelete = Array.from(this.cache.keys()).filter(key => key.startsWith(`${userId}:`));\n    keysToDelete.forEach(key => this.cache.delete(key));\n    this.userRoleCache.delete(userId);\n  }\n\n  /**\n   * Invalidate cache for specific resource\n   */\n  invalidateResource(resource: string): void {\n    const keysToDelete = Array.from(this.cache.keys()).filter(key => key.includes(`:${resource}:`));\n    keysToDelete.forEach(key => this.cache.delete(key));\n  }\n\n  /**\n   * Clear all cache\n   */\n  clear(): void {\n    this.cache.clear();\n    this.userRoleCache.clear();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): { size: number; hitRate: number; memoryUsage: number } {\n    // This would be implemented with proper statistics tracking\n    return {\n      size: this.cache.size,\n      hitRate: 0, // Would track hits vs misses\n      memoryUsage: 0, // Would calculate memory usage\n    };\n  }\n\n  /**\n   * Generate cache key\n   */\n  private generateKey(userId: string, resource: string, action: string, scope?: PermissionScope): string {\n    const scopeKey = scope ? `${scope.type}:${scope.value || ''}` : 'global';\n    return `${userId}:${resource}:${action}:${scopeKey}`;\n  }\n}\n\n// =============================================================================\n// Permissions Service Class\n// =============================================================================\n\n/**\n * Enterprise permissions service with advanced RBAC features\n */\nexport class PermissionsService {\n  private readonly baseUrl = '/permissions';\n  private readonly client = apiClient;\n  private readonly cache = new PermissionCache();\n  private readonly policyEvaluator = new PolicyEvaluator();\n  private ws: WebSocket | null = null;\n\n  // ===========================================================================\n  // Permission Management\n  // ===========================================================================\n\n  /**\n   * Create a new permission\n   * \n   * @param data - Permission creation data\n   * @param config - Request configuration\n   * @returns Promise resolving to created permission\n   * \n   * @example\n   * ```typescript\n   * const permission = await permissionsService.createPermission({\n   *   name: 'Edit User Profile',\n   *   resource: 'user',\n   *   action: 'update',\n   *   scope: { type: 'user', value: 'self' }\n   * });\n   * ```\n   */\n  async createPermission(\n    data: z.infer<typeof createPermissionSchema>,\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<Permission>> {\n    const validatedData = createPermissionSchema.parse(data);\n\n    return this.client.post<typeof validatedData, Permission>(\n      `${this.baseUrl}`,\n      validatedData,\n      {\n        ...config,\n        cancelKey: 'permission.create',\n        cache: { enabled: false },\n      }\n    );\n  }\n\n  /**\n   * Get permission by ID\n   * \n   * @param id - Permission ID\n   * @param config - Request configuration\n   * @returns Promise resolving to permission\n   */\n  async getPermission(\n    id: string,\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<Permission>> {\n    return this.client.get<Permission>(\n      `${this.baseUrl}/${id}`,\n      {\n        ...config,\n        cancelKey: `permission.get.${id}`,\n        cache: {\n          enabled: true,\n          ttl: 600000, // 10 minutes\n          key: `permission:${id}`,\n        },\n      }\n    );\n  }\n\n  /**\n   * List permissions\n   * \n   * @param params - Query parameters\n   * @param config - Request configuration\n   * @returns Promise resolving to paginated permissions\n   */\n  async listPermissions(\n    params: {\n      page?: number;\n      limit?: number;\n      resource?: PermissionResource;\n      action?: PermissionAction;\n      scope?: string;\n      search?: string;\n    } = {},\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<PaginatedResponse<Permission>>> {\n    return this.client.get<PaginatedResponse<Permission>>(\n      this.baseUrl,\n      {\n        ...config,\n        params,\n        cancelKey: 'permission.list',\n        cache: {\n          enabled: true,\n          ttl: 300000, // 5 minutes\n          key: `permissions:list:${JSON.stringify(params)}`,\n        },\n      }\n    );\n  }\n\n  /**\n   * Update permission\n   * \n   * @param id - Permission ID\n   * @param data - Update data\n   * @param config - Request configuration\n   * @returns Promise resolving to updated permission\n   */\n  async updatePermission(\n    id: string,\n    data: Partial<z.infer<typeof createPermissionSchema>>,\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<Permission>> {\n    return this.client.patch<typeof data, Permission>(\n      `${this.baseUrl}/${id}`,\n      data,\n      {\n        ...config,\n        cancelKey: `permission.update.${id}`,\n        cache: {\n          enabled: false,\n          invalidateOn: [`GET:/permissions/${id}`, 'GET:/permissions'],\n        },\n      }\n    );\n  }\n\n  /**\n   * Delete permission\n   * \n   * @param id - Permission ID\n   * @param config - Request configuration\n   * @returns Promise resolving to deletion confirmation\n   */\n  async deletePermission(\n    id: string,\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<void>> {\n    const response = await this.client.delete<void>(\n      `${this.baseUrl}/${id}`,\n      {\n        ...config,\n        cancelKey: `permission.delete.${id}`,\n        cache: {\n          enabled: false,\n          invalidateOn: [`GET:/permissions/${id}`, 'GET:/permissions'],\n        },\n      }\n    );\n\n    if (response.success) {\n      // Invalidate cache since permissions changed\n      this.cache.clear();\n    }\n\n    return response;\n  }\n\n  // ===========================================================================\n  // Role Management\n  // ===========================================================================\n\n  /**\n   * Create a new role\n   * \n   * @param data - Role creation data\n   * @param config - Request configuration\n   * @returns Promise resolving to created role\n   * \n   * @example\n   * ```typescript\n   * const role = await permissionsService.createRole({\n   *   name: 'Content Editor',\n   *   description: 'Can create and edit content',\n   *   permissions: ['perm1', 'perm2'],\n   *   metadata: { level: 1, priority: 10 }\n   * });\n   * ```\n   */\n  async createRole(\n    data: z.infer<typeof createRoleSchema>,\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<Role>> {\n    const validatedData = createRoleSchema.parse(data);\n\n    return this.client.post<typeof validatedData, Role>(\n      `${this.baseUrl}/roles`,\n      validatedData,\n      {\n        ...config,\n        cancelKey: 'role.create',\n        cache: { enabled: false },\n      }\n    );\n  }\n\n  /**\n   * Get role by ID\n   * \n   * @param id - Role ID\n   * @param config - Request configuration\n   * @returns Promise resolving to role\n   */\n  async getRole(\n    id: string,\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<Role>> {\n    return this.client.get<Role>(\n      `${this.baseUrl}/roles/${id}`,\n      {\n        ...config,\n        cancelKey: `role.get.${id}`,\n        cache: {\n          enabled: true,\n          ttl: 600000, // 10 minutes\n          key: `role:${id}`,\n        },\n      }\n    );\n  }\n\n  /**\n   * List roles\n   * \n   * @param params - Query parameters\n   * @param config - Request configuration\n   * @returns Promise resolving to paginated roles\n   */\n  async listRoles(\n    params: {\n      page?: number;\n      limit?: number;\n      parentRoleId?: string;\n      isActive?: boolean;\n      search?: string;\n      includePermissions?: boolean;\n    } = {},\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<PaginatedResponse<Role>>> {\n    return this.client.get<PaginatedResponse<Role>>(\n      `${this.baseUrl}/roles`,\n      {\n        ...config,\n        params,\n        cancelKey: 'role.list',\n        cache: {\n          enabled: true,\n          ttl: 300000, // 5 minutes\n          key: `roles:list:${JSON.stringify(params)}`,\n        },\n      }\n    );\n  }\n\n  /**\n   * Update role\n   * \n   * @param id - Role ID\n   * @param data - Update data\n   * @param config - Request configuration\n   * @returns Promise resolving to updated role\n   */\n  async updateRole(\n    id: string,\n    data: Partial<z.infer<typeof createRoleSchema>>,\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<Role>> {\n    const response = await this.client.patch<typeof data, Role>(\n      `${this.baseUrl}/roles/${id}`,\n      data,\n      {\n        ...config,\n        cancelKey: `role.update.${id}`,\n        cache: {\n          enabled: false,\n          invalidateOn: [`GET:/permissions/roles/${id}`, 'GET:/permissions/roles'],\n        },\n      }\n    );\n\n    if (response.success) {\n      // Invalidate permission cache since role changed\n      this.cache.clear();\n    }\n\n    return response;\n  }\n\n  /**\n   * Delete role\n   * \n   * @param id - Role ID\n   * @param config - Request configuration\n   * @returns Promise resolving to deletion confirmation\n   */\n  async deleteRole(\n    id: string,\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<void>> {\n    const response = await this.client.delete<void>(\n      `${this.baseUrl}/roles/${id}`,\n      {\n        ...config,\n        cancelKey: `role.delete.${id}`,\n        cache: {\n          enabled: false,\n          invalidateOn: [`GET:/permissions/roles/${id}`, 'GET:/permissions/roles'],\n        },\n      }\n    );\n\n    if (response.success) {\n      // Invalidate cache since roles changed\n      this.cache.clear();\n    }\n\n    return response;\n  }\n\n  // ===========================================================================\n  // Role Assignment Management\n  // ===========================================================================\n\n  /**\n   * Assign role to user\n   * \n   * @param data - Role assignment data\n   * @param config - Request configuration\n   * @returns Promise resolving to role assignment\n   */\n  async assignRole(\n    data: z.infer<typeof assignRoleSchema>,\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<UserRoleAssignment>> {\n    const validatedData = assignRoleSchema.parse(data);\n\n    const response = await this.client.post<typeof validatedData, UserRoleAssignment>(\n      `${this.baseUrl}/assignments`,\n      validatedData,\n      {\n        ...config,\n        cancelKey: `role.assign.${data.userId}.${data.roleId}`,\n        cache: { enabled: false },\n      }\n    );\n\n    if (response.success) {\n      // Invalidate user's permission cache\n      this.cache.invalidateUser(data.userId);\n    }\n\n    return response;\n  }\n\n  /**\n   * Revoke role from user\n   * \n   * @param assignmentId - Role assignment ID\n   * @param config - Request configuration\n   * @returns Promise resolving to revocation confirmation\n   */\n  async revokeRole(\n    assignmentId: string,\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<void>> {\n    const response = await this.client.delete<void>(\n      `${this.baseUrl}/assignments/${assignmentId}`,\n      {\n        ...config,\n        cancelKey: `role.revoke.${assignmentId}`,\n        cache: { enabled: false },\n      }\n    );\n\n    if (response.success) {\n      // Would need to know userId to invalidate specific user cache\n      // For now, clear all cache\n      this.cache.clear();\n    }\n\n    return response;\n  }\n\n  /**\n   * Get user's role assignments\n   * \n   * @param userId - User ID\n   * @param config - Request configuration\n   * @returns Promise resolving to user's role assignments\n   */\n  async getUserRoles(\n    userId: string,\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<UserRoleAssignment[]>> {\n    return this.client.get<UserRoleAssignment[]>(\n      `${this.baseUrl}/users/${userId}/roles`,\n      {\n        ...config,\n        cancelKey: `user.roles.${userId}`,\n        cache: {\n          enabled: true,\n          ttl: 300000, // 5 minutes\n          key: `user:roles:${userId}`,\n        },\n      }\n    );\n  }\n\n  /**\n   * Get role assignments\n   * \n   * @param params - Query parameters\n   * @param config - Request configuration\n   * @returns Promise resolving to paginated role assignments\n   */\n  async getRoleAssignments(\n    params: {\n      page?: number;\n      limit?: number;\n      userId?: string;\n      roleId?: string;\n      isActive?: boolean;\n    } = {},\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<PaginatedResponse<UserRoleAssignment>>> {\n    return this.client.get<PaginatedResponse<UserRoleAssignment>>(\n      `${this.baseUrl}/assignments`,\n      {\n        ...config,\n        params,\n        cancelKey: 'role.assignments',\n        cache: {\n          enabled: true,\n          ttl: 300000, // 5 minutes\n          key: `assignments:${JSON.stringify(params)}`,\n        },\n      }\n    );\n  }\n\n  // ===========================================================================\n  // Permission Checking\n  // ===========================================================================\n\n  /**\n   * Check if user has permission\n   * \n   * @param request - Permission check request\n   * @param config - Request configuration\n   * @returns Promise resolving to permission check result\n   * \n   * @example\n   * ```typescript\n   * const canEdit = await permissionsService.hasPermission({\n   *   userId: 'user123',\n   *   resource: 'document',\n   *   action: 'update',\n   *   scope: { type: 'resource', value: 'doc456' }\n   * });\n   * \n   * if (canEdit.success && canEdit.data.granted) {\n   *   // User can edit the document\n   * }\n   * ```\n   */\n  async hasPermission(\n    request: z.infer<typeof permissionCheckSchema>,\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<PermissionCheckResult>> {\n    const validatedRequest = permissionCheckSchema.parse(request);\n\n    // Check cache first\n    const cached = this.cache.get(\n      validatedRequest.userId,\n      validatedRequest.resource,\n      validatedRequest.action,\n      validatedRequest.scope\n    );\n\n    if (cached) {\n      return {\n        success: true,\n        data: cached,\n        meta: {\n          timestamp: new Date().toISOString(),\n          requestId: crypto.randomUUID(),\n          cached: true,\n        },\n      };\n    }\n\n    const response = await this.client.post<typeof validatedRequest, PermissionCheckResult>(\n      `${this.baseUrl}/check`,\n      validatedRequest,\n      {\n        ...config,\n        cancelKey: `permission.check.${validatedRequest.userId}`,\n      }\n    );\n\n    if (response.success) {\n      // Cache the result\n      this.cache.set(\n        validatedRequest.userId,\n        validatedRequest.resource,\n        validatedRequest.action,\n        response.data,\n        validatedRequest.scope\n      );\n    }\n\n    return response;\n  }\n\n  /**\n   * Check multiple permissions in batch\n   * \n   * @param request - Bulk permission check request\n   * @param config - Request configuration\n   * @returns Promise resolving to bulk permission check results\n   */\n  async hasPermissionsBulk(\n    request: z.infer<typeof bulkPermissionCheckSchema>,\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<PermissionCheckResult[]>> {\n    const validatedRequest = bulkPermissionCheckSchema.parse(request);\n\n    return this.client.post<typeof validatedRequest, PermissionCheckResult[]>(\n      `${this.baseUrl}/check/bulk`,\n      validatedRequest,\n      {\n        ...config,\n        cancelKey: `permission.check.bulk.${validatedRequest.userId}`,\n      }\n    );\n  }\n\n  /**\n   * Get effective permissions for user\n   * \n   * @param userId - User ID\n   * @param scope - Optional scope filter\n   * @param config - Request configuration\n   * @returns Promise resolving to user's effective permissions\n   */\n  async getEffectivePermissions(\n    userId: string,\n    scope?: PermissionScope,\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<{\n    permissions: Permission[];\n    roles: Role[];\n    inheritedFrom: Record<string, string[]>; // permission ID -> role IDs\n  }>> {\n    return this.client.get(\n      `${this.baseUrl}/users/${userId}/effective`,\n      {\n        ...config,\n        params: scope ? { scope: JSON.stringify(scope) } : {},\n        cancelKey: `permission.effective.${userId}`,\n        cache: {\n          enabled: true,\n          ttl: 300000, // 5 minutes\n          key: `effective:${userId}:${JSON.stringify(scope)}`,\n        },\n      }\n    );\n  }\n\n  // ===========================================================================\n  // Utility Methods\n  // ===========================================================================\n\n  /**\n   * Check permission with caching (synchronous)\n   * \n   * @param userId - User ID\n   * @param resource - Resource type\n   * @param action - Action type\n   * @param scope - Optional scope\n   * @returns Cached permission result or null\n   */\n  checkCached(\n    userId: string,\n    resource: PermissionResource,\n    action: PermissionAction,\n    scope?: PermissionScope\n  ): PermissionCheckResult | null {\n    return this.cache.get(userId, resource, action, scope);\n  }\n\n  /**\n   * Preload permissions for user (for caching)\n   * \n   * @param userId - User ID\n   * @param permissions - Permissions to preload\n   * @param config - Request configuration\n   * @returns Promise resolving to preloaded permissions\n   */\n  async preloadPermissions(\n    userId: string,\n    permissions: Array<{ resource: PermissionResource; action: PermissionAction; scope?: PermissionScope }>,\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<PermissionCheckResult[]>> {\n    const bulkRequest = {\n      userId,\n      checks: permissions,\n    };\n\n    const response = await this.hasPermissionsBulk(bulkRequest, config);\n\n    if (response.success) {\n      // Cache all results\n      response.data.forEach((result, index) => {\n        const perm = permissions[index];\n        this.cache.set(userId, perm.resource, perm.action, result, perm.scope);\n      });\n    }\n\n    return response;\n  }\n\n  /**\n   * Clear permission cache\n   * \n   * @param userId - Optional user ID to clear specific user cache\n   */\n  clearCache(userId?: string): void {\n    if (userId) {\n      this.cache.invalidateUser(userId);\n    } else {\n      this.cache.clear();\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): { size: number; hitRate: number; memoryUsage: number } {\n    return this.cache.getStats();\n  }\n\n  // ===========================================================================\n  // Audit and Monitoring\n  // ===========================================================================\n\n  /**\n   * Get permission audit logs\n   * \n   * @param params - Query parameters\n   * @param config - Request configuration\n   * @returns Promise resolving to paginated audit logs\n   */\n  async getAuditLogs(\n    params: {\n      page?: number;\n      limit?: number;\n      userId?: string;\n      resource?: PermissionResource;\n      action?: string;\n      dateFrom?: string;\n      dateTo?: string;\n      result?: boolean;\n    } = {},\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<PaginatedResponse<PermissionAuditLog>>> {\n    return this.client.get<PaginatedResponse<PermissionAuditLog>>(\n      `${this.baseUrl}/audit`,\n      {\n        ...config,\n        params,\n        cancelKey: 'permission.audit',\n        cache: {\n          enabled: true,\n          ttl: 60000, // 1 minute\n          key: `audit:${JSON.stringify(params)}`,\n        },\n      }\n    );\n  }\n\n  /**\n   * Get permission usage statistics\n   * \n   * @param params - Query parameters\n   * @param config - Request configuration\n   * @returns Promise resolving to usage statistics\n   */\n  async getUsageStats(\n    params: {\n      dateFrom?: string;\n      dateTo?: string;\n      groupBy?: 'user' | 'resource' | 'action' | 'day' | 'week' | 'month';\n    } = {},\n    config: EnhancedApiRequestConfig = {}\n  ): Promise<ApiResponse<{\n    totalChecks: number;\n    grantedChecks: number;\n    deniedChecks: number;\n    grantRate: number;\n    byResource: Record<PermissionResource, number>;\n    byAction: Record<PermissionAction, number>;\n    timeline: Array<{ date: string; checks: number; granted: number; denied: number }>;\n  }>> {\n    return this.client.get(\n      `${this.baseUrl}/stats/usage`,\n      {\n        ...config,\n        params,\n        cancelKey: 'permission.stats.usage',\n        cache: {\n          enabled: true,\n          ttl: 300000, // 5 minutes\n          key: `stats:usage:${JSON.stringify(params)}`,\n        },\n      }\n    );\n  }\n\n  // ===========================================================================\n  // Real-time Updates\n  // ===========================================================================\n\n  /**\n   * Connect to real-time permission updates\n   * \n   * @param userId - User ID for personalized updates\n   * @returns Promise resolving when connection is established\n   */\n  async connectRealtime(userId: string): Promise<void> {\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      return;\n    }\n\n    const wsUrl = `${import.meta.env.VITE_WS_URL || 'ws://localhost:3000'}/permissions/ws?userId=${userId}`;\n    this.ws = new WebSocket(wsUrl);\n\n    return new Promise((resolve, reject) => {\n      if (!this.ws) {\n        reject(new Error('Failed to create WebSocket'));\n        return;\n      }\n\n      this.ws.onopen = () => {\n        console.log('[PermissionWS] Connected');\n        resolve();\n      };\n\n      this.ws.onmessage = (event) => {\n        try {\n          const message = JSON.parse(event.data);\n          this.handleRealtimeMessage(message);\n        } catch (error) {\n          console.error('[PermissionWS] Failed to parse message:', error);\n        }\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('[PermissionWS] Error:', error);\n        reject(error);\n      };\n\n      this.ws.onclose = () => {\n        console.log('[PermissionWS] Disconnected');\n      };\n    });\n  }\n\n  /**\n   * Disconnect from real-time updates\n   */\n  disconnectRealtime(): void {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n\n  /**\n   * Handle real-time permission messages\n   */\n  private handleRealtimeMessage(message: any): void {\n    switch (message.type) {\n      case 'permission.granted':\n      case 'permission.revoked':\n      case 'role.assigned':\n      case 'role.revoked':\n        // Invalidate affected user's cache\n        if (message.userId) {\n          this.cache.invalidateUser(message.userId);\n        }\n        break;\n      case 'permission.updated':\n      case 'role.updated':\n        // Invalidate all cache since permissions/roles changed\n        this.cache.clear();\n        break;\n      default:\n        console.warn('[PermissionWS] Unknown message type:', message.type);\n    }\n  }\n\n  /**\n   * Get real-time connection status\n   */\n  get isRealtimeConnected(): boolean {\n    return this.ws?.readyState === WebSocket.OPEN;\n  }\n}\n\n// Export singleton instance\nexport const permissionsService = new PermissionsService();\n\n// Export validation schemas for external use\nexport {\n  createPermissionSchema,\n  createRoleSchema,\n  assignRoleSchema,\n  permissionCheckSchema,\n  bulkPermissionCheckSchema,\n};\n\n// Export utility constants\nexport {\n  RESOURCES,\n  ACTIONS,\n  PERMISSION_SETS,\n  SYSTEM_ROLES,\n};